from __future__ import annotations
from ctypes import Union
import openfermion as of
import cirq
import numpy as np
from typing import Callable, Optional, Tuple, Union, Sequence
import abc

from qutlet.models.fockModel import FockModel
from qutlet.models.fermionicModel import FermionicModel
from qutlet.utilities import (
    flatten,
    bravyi_kitaev_fast_wrapper,
    index_bits,
    sum_even,
    jw_eigenspectrum_at_particle_number,
    sum_odd,
)

from openfermion import get_sparse_operator


def set_initial_state_circuit(
    self,
    name: str,
    initial_state: Union[int, Sequence[int]] = None,
):
    """Inserts the cirq.OP_TREE generated by _get_initial_state_circuit into the circuit

    Args:
        name (str): the name of the type of initial state desired
        system_fermions: the number of fermions in the system
        initial_state (Union[int, Sequence[int]], optional): the indices of qubits that start n the 1 state. Defaults to 0 (i.e. all flipped down).
        An int input will be converted to binary and interpreted as a computational basis vector
        e.g. 34 = 100010 means the first and fifth qubits are initialized at one.
        rows (int): the rows taken from the Q matrix (rows of Q), where Q is defined from b* = Qa*, with a* creation operators.
                                                            Q diagonalizes system_fermions rows of the non-interacting hamiltonian
    """
    initial_state = self._process_initial_state_input(initial_state=initial_state)
    op_tree = self._get_initial_state_circuit(name=name, initial_state=initial_state)
    if op_tree is not None:
        self.circuit.append(op_tree)


def _process_initial_state_input(self, initial_state):
    # this method exists because the way to initiate the circuit is not so straight-forward
    # one could either put a int in initial state to get a binary computational state
    # or use nh to get some spin sectors. It's all very complex and deserves its own function
    if isinstance(initial_state, int):
        initial_state = index_bits(bin(initial_state), right_to_left=True)
    if initial_state is None:
        initial_state = list(
            sorted(
                [2 * k for k in range(self.system_fermions[0])]
                + [2 * k + 1 for k in range(self.system_fermions[1])]
            )
        )
    if (
        len(initial_state) != sum(self.system_fermions)
        or sum_even(initial_state) != self.system_fermions[0]
        or sum_odd(initial_state) != self.system_fermions[1]
    ):
        raise ValueError(
            "Mismatch between initial state and desired number of fermions. Initial state: {}, system_fermions: {}".format(
                initial_state, self.system_fermions
            )
        )
    return initial_state


def gaussian_state_circuit(self):
    quadratic_hamiltonian = self.get_quadratic_hamiltonian_wrapper(
        self.fock_hamiltonian
    )
    op_tree = of.prepare_gaussian_state(
        qubits=self.qubits,
        quadratic_hamiltonian=quadratic_hamiltonian,
        occupied_orbitals=list(range(sum(self.system_fermions))),
        initial_state=0,
    )
    return op_tree


def slater_state_circuit(self):
    _, unitary_rows = self.diagonalize_non_interacting_hamiltonian()
    op_tree = of.prepare_slater_determinant(
        qubits=self.qubits,
        slater_determinant_matrix=unitary_rows[: sum(self.system_fermions), :],
        initial_state=0,
    )
    return op_tree


@staticmethod
def computational_state_circuit(initial_state, qubits):
    op_tree = [cirq.X(qubits[ind]) for ind in initial_state]
    return op_tree


@staticmethod
def uniform_superposition_state_circuit(initial_state, qubits):
    op_tree = FermionicModel.computational_state_circuit(initial_state, qubits)
    op_tree += [cirq.H(qubits[ind]) for ind in initial_state]
    return op_tree


@staticmethod
def dicke_state_circuit(system_fermions, qubits):
    # TODO: implement the circuit
    op_tree = []
    return op_tree


def _get_initial_state_circuit(
    self,
    name: str,
    initial_state: Union[int, Sequence[int]],
):
    if name is None:
        name == "none"
    self.initial_state_name = name

    if name == "none":
        return None
    elif name == "computational":
        return FermionicModel.computational_state_circuit(
            initial_state=initial_state, qubits=self.qubits
        )
    elif name == "uniform_superposition":
        return FermionicModel.uniform_superposition_state_circuit(
            initial_state=initial_state, qubits=self.qubits
        )
    elif name == "dicke":
        return FermionicModel.dicke_state_circuit(
            system_fermions=self.system_fermions, qubits=self.qubits
        )
    elif name == "slater":
        return self.slater_state_circuit()
    elif name == "gaussian":
        return self.gaussian_state_circuit()
    else:
        raise NameError("No initial state named {}".format(name))
