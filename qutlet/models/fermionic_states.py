from __future__ import annotations
import openfermion as of
import cirq
from typing import Union, Sequence

from qutlet.models.fermionic_model import FermionicModel
from qutlet.utilities import (
    index_bits,
    sum_even,
    sum_odd,
)


def set_initial_state_circuit(
    self,
    name: str,
    initial_state: Union[int, Sequence[int]] = None,
):
    """Inserts the cirq.OP_TREE generated by _get_initial_state_circuit into the circuit

    Args:
        name (str): the name of the type of initial state desired
        n_electrons: the number of fermions in the system
        initial_state (Union[int, Sequence[int]], optional): the indices of qubits that start n the 1 state. Defaults to 0 (i.e. all flipped down).
        An int input will be converted to binary and interpreted as a computational basis vector
        e.g. 34 = 100010 means the first and fifth qubits are initialized at one.
        rows (int): the rows taken from the Q matrix (rows of Q), where Q is defined from b* = Qa*, with a* creation operators.
                                                            Q diagonalizes n_electrons rows of the non-interacting hamiltonian
    """
    initial_state = self._process_initial_state_input(initial_state=initial_state)
    op_tree = self._get_initial_state_circuit(name=name, initial_state=initial_state)
    if op_tree is not None:
        self.circuit.append(op_tree)


def _process_initial_state_input(self, initial_state):
    # this method exists because the way to initiate the circuit is not so straight-forward
    # one could either put a int in initial state to get a binary computational state
    # or use nh to get some spin sectors. It's all very complex and deserves its own function
    if isinstance(initial_state, int):
        initial_state = index_bits(bin(initial_state), right_to_left=True)
    if initial_state is None:
        initial_state = list(
            sorted(
                [2 * k for k in range(self.n_electrons[0])]
                + [2 * k + 1 for k in range(self.n_electrons[1])]
            )
        )
    if (
        len(initial_state) != sum(self.n_electrons)
        or sum_even(initial_state) != self.n_electrons[0]
        or sum_odd(initial_state) != self.n_electrons[1]
    ):
        raise ValueError(
            "Mismatch between initial state and desired number of fermions. Initial state: {}, n_electrons: {}".format(
                initial_state, self.n_electrons
            )
        )
    return initial_state


def gaussian_state_circuit(self):
    quadratic_hamiltonian = self.get_quadratic_hamiltonian_wrapper(
        self.fock_hamiltonian
    )
    op_tree = of.prepare_gaussian_state(
        qubits=self.qubits,
        quadratic_hamiltonian=quadratic_hamiltonian,
        occupied_orbitals=list(range(sum(self.n_electrons))),
        initial_state=0,
    )
    return op_tree


def slater_state_circuit(self):
    _, unitary_rows = self.diagonalize_non_interacting_hamiltonian()
    op_tree = of.prepare_slater_determinant(
        qubits=self.qubits,
        slater_determinant_matrix=unitary_rows[: sum(self.n_electrons), :],
        initial_state=0,
    )
    return op_tree


def computational_state_circuit(initial_state, qubits):
    op_tree = [cirq.X(qubits[ind]) for ind in initial_state]
    return op_tree


def uniform_superposition_state_circuit(initial_state, qubits):
    op_tree = FermionicModel.computational_state_circuit(initial_state, qubits)
    op_tree += [cirq.H(qubits[ind]) for ind in initial_state]
    return op_tree


def dicke_state_circuit(n_electrons, qubits):
    # TODO: implement the circuit
    op_tree = []
    return op_tree


def get_initial_state_circuit(
    self,
    name: str,
    initial_state: Union[int, Sequence[int]],
):
    if name is None:
        name == "none"
    self.initial_state_name = name

    if name == "none":
        return None
    elif name == "computational":
        return FermionicModel.computational_state_circuit(
            initial_state=initial_state, qubits=self.qubits
        )
    elif name == "uniform_superposition":
        return FermionicModel.uniform_superposition_state_circuit(
            initial_state=initial_state, qubits=self.qubits
        )
    elif name == "dicke":
        return FermionicModel.dicke_state_circuit(
            n_electrons=self.n_electrons, qubits=self.qubits
        )
    elif name == "slater":
        return self.slater_state_circuit()
    elif name == "gaussian":
        return self.gaussian_state_circuit()
    else:
        raise NameError("No initial state named {}".format(name))
